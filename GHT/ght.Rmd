---
title: "Groupement hospitalier de territoire (GHT)"
author: "JcB"
date: "16/01/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# faire de la place
# rm(list=ls(all=TRUE))
```
Comment extaire les GHT de la Région Grand Est (RGE) ?
On part des communes de la France Entière. Puis on extrait les communes de la RGE. Ensuite on merge ce fichier avec celui des GHT.
On obtient un spatialPolygonDataFrame contenant le contour des communes (polygons) et le GHT d'appartenance.

Fichiers nécéssaires
====================
IGN_GEOFLA_2016/Fichier_SHP/COMMUNE
"~/Downloads/Liste_GrandEst_COM_CodePMSI_GHT_27102016_VF.csv": liste  

Fichier des communes faisant partie de GHT du grand est (transmis par Lagille)
ght2 <- read.csv2("~/Downloads/Liste_GrandEst_COM_CodePMSI_GHT_27102016_VF.csv")

Fichiers créés
==============

- ght.Rda: GHT de la région gand est avec les communes
- save(ght3, file = "GHT/limites_des_ght.Rda")

Bibliothèques nécessaires
=========================
```{r biblio}
library(sp)
library(rgdal)
library(maptools)
source("../Carto_utilitaires.R") # suprimer ../ si console
```


GHT
===
```{r ght}
# Mac book air
#dsn <- "/Users/jcb/Documents/Cartographie/Donnee_IGN/COMMUNE"

# IMac (fichiers 2015)
# dsn <- "/Users/jean-claudebartier/Documents/CARTOGRAPHIE/CartographieR/IGN_GEOFLA_2015/Fichier_SHP/COMMUNE"

# IMac - fichiers 2016
dsn <- "/Users/jean-claudebartier/Documents/CARTOGRAPHIE/CartographieR/IGN_GEOFLA_2016/COMMUNE"
```

On commmence par charger la carte de France avec toutes les communes.
```{r france}
# carte de France avec toutes les communes
france <- readOGR(dsn = dsn, layer = "COMMUNE")
```

On ne conserve que la RGE
```{r RGE}

# départements de la RGE # Dep
dep.rge <-  c("08", "51", "10", "52", "55", "54", "57", "88", "67", "68")

# la fonction add0 ajoute un zero denent un département dontle code est < 10

# Contour des départements RGE
dep <- france[france$CODE_DEPT %in% dep.rge,]
dep <- unionSpatialPolygons(dep, IDs = dep@data$CODE_DEPT)
plot(dep, axes = TRUE, main = "Départements du Grand Est")
save(dep, file = "../GHT/contour_departements.Rda")
# dep est un spatalPolygonf => pas de data

# load(../GHT/contour_departements.Rda")
# le contour des déartements n'est pas suerposable  celui des GHT.
# essayer:
# --------
# plot(ght5) # carte des GHT
# plot(dep, border = "red", lty = 3, add = T) # carte des departements en pointillé rouge
# b <- coordinates(dep) # n° des départements
# text(b, names(dep), col = "red") # affiche le n° du dep.
```

```{r}
# merging avec le fichier de Lagille
# ensemble des communes constituant les GHT de la RGE. Liste transmise par E.Lagille
# Lecture du fichier
pathGht <- "/Users/jean-claudebartier/Documents/Resural/Stat Resural/RPU_Doc/RPU_Carto-Pop-Alsace/Cartographie/ght_com.csv"
ght2 <- read.csv(pathGht) # 5928 observations of 7 variables
x <- add0(ght2$code_com) # ajoute un 0 devant un Finess trop court
ght2$code_com <- x

# La carte fournie par l'ARS est fausse car le GHT2 englobe les communes des départements 21 et 71 qui ne font pas partie de la région grand est. Il faut donc les éliminer:
ght2 <-ght2[ght2$DEP != 21 & ght2$DEP != 71 ,] # 5197 observations of 7 variables

ght  <- france[france@data$INSEE_COM %in% ght2$code_com,] # ght est un spatialPolygonsDataFrame

plot(ght, axes = TRUE, main = "GHT - Communes de la RGE")

names(ght)

# on ajoute la limite des départements
plot(dep, border = "red", lty = 3, lwd = 3, add = T) # carte des departements en pointillé rouge

# __ght__ est la carte des communes de la RGE.
# carte des GHT (limites avec les comunes)
# ght  <- france[france@data$INSEE_COM %in% ght2$code_com,]
# plot(ght, axes = TRUE)

# on vérfie que la projection est renseignée:
ght@proj4string

save(ght, file = "../GHT/ghtRGE_avecCommunes.Rda")
```

On fait une jointure avec le fichier des GHT
```{r}
#merging des fichiers
##Jointure utilisant la méthode match qui ne modifie pas l'ordre des lignes
ght2$code_com <- add0(ght2$code_com)
ght <- Attrib.Join(ght2, ght, "code_com", "INSEE_COM") # spatialPolygonsDataFame
names(ght)
```

__ght__ est un spatialPolygonDataFrame => possède un dataFrame et plot(ght) dessine les GHT de l'est avec les communes.

NB: si le champ PoPULATION n'est pas transformé en numérique, tapply génère une erreur. Voir: http://stackoverflow.com/questions/18045096/r-error-sum-not-meaningful-for-factors


```{r}
# trace les limites des GHT
ght3 <- unionSpatialPolygons(a, IDs = a@data$GHT)
plot(ght3)

save(ght3, file = "../GHT/limites_des_ght.Rda")
```

```{r}

# exemple: dessine les communes et en surimpression les limites des GHT. 
plot(a, border = "gray")
plot(ght3, border = "red", lwd = 3, add = TRUE)

# centroïdes des 12 GHT
b <- coordinates(ght3)
text(b, names(ght3))
```

```{r}
# Détails des slots
c <- sapply(slot(ght3, "polygons"), slot, "area")
d <- sapply(slot(ght3, "polygons"), slot, "ID")
# e <- sapply(slot(GHT3, "polygons"), slot, "labpt")

ght_geo <- rbind(c,d)
ght_geo <- t(ght_geo)
colnames(ght_geo) <- c("surface", "ID")
```

On peut en déduire le plus grand, le plus petit...

# en couleur
```{r}
library(RColorBrewer)
coul <- brewer.pal(n=12, name = "Set3")
ght <- unionSpatialPolygons(a, IDs = a@data$GHT)
plot(ght, col = coul, axes = TRUE)
b <- coordinates(ght)
text(b, names(ght))

```

Représentation par GHT
======================
Exemple GHT n°1
---------------
```{r}
ght1 <- a[a@data$GHT == 1,]
plot(ght1)
ght01 <- unionSpatialPolygons(ght1, ght1@data$GHT == 1)
plot(ght01, main = "GHT n°1", axes = T)

# préfecture
ght1@data[which(ght1@data$STATUT == "Préfecture de département"),]
x <- ght1@data[which(ght1@data$STATUT == "Préfecture de département"),]$X_CHF_LIEU
y <- ght1@data[which(ght1@data$STATUT == "Préfecture de département"),]$Y_CHF_LIEU
points(x,y, pch = 16, col = "red")
text(x,y, ght1@data[which(ght1@data$STATUT == "Préfecture de département"),]$NOM_COM, pos = 1, cex = 0.8)

```

Hôpitaux-SU de la région grand est
==================================

On récupère les fichiers correspondants dans le dossier __/Users/jean-claudebartier/Documents/Resural/Stat Resural/RPU_Doc/RPU_Carto-Pop-Alsace/Cartographie/Structures_Urgence_FEDorU__. Il y a 3 fichiers au format csv correspondant aux anciennes régions.
```{r}

path = "/Users/jean-claudebartier/Documents/Resural/Stat Resural/RPU_Doc/RPU_Carto-Pop-Alsace/Cartographie/Structures_Urgence_FEDorU/"
a <- paste0(path, "Structures d'urgence_Als.csv")
b <- paste0(path, "Structures d'urgence_Lor.csv")
c <- paste0(path, "Structures d'urgence_CA.csv")

a2<-read.csv(a, skip = 1)
b2<-read.csv(b, skip = 1)
c2<-read.csv(c, skip = 1)
hopRge <- rbind(a2,b2,c2)
# On ne cnserve que les colonnes ayant un intéret. Les col. 12 et 13 contiennent latitude et longitude en WS84.
hopRge <- hopRge[, c(2,3,7,8,9,10,15,16,20,21)]

d2 <- hopRge
# on transforme mes virgules en points puis en numéric
d2$Longitude <- as.numeric(gsub(",",".", d2$Longitude))
d2$Latitude <- as.numeric(gsub(",",".", d2$Latitude))

coordinates(d2) = ~ Longitude + Latitude
proj4string(d2) = CRS("+proj=longlat +datum=WGS84")

plot(d2, xlab = "Longitude", ylab = "Latitude", axes = TRUE, las = 2, main = "SU Région Grand Est (WSG84)")

# Reprojeter au format Lambert 93
# -------------------------------
# EPSG:2154 Lambert 93
newProj = CRS("+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs")
su_alca_L93 <- spTransform(d2, newProj)
plot(su_alca_L93, xlab = "Longitude", ylab = "Latitude", axes = TRUE, las = 1, main = "SU Région Grand Est (Lambert 93)")

plot(su_alca_L93[su_alca_L93$SMUR == "oui",], pch = 16, col = "red", xlab = "Longitude", ylab = "Latitude", axes = TRUE, las = 2, main = "SAMU Région Grand Est (Lambert93)")

plot(su_alca_L93[su_alca_L93$SAMU == "oui",], pch = 15, col = "blue", xlab = "Longitude", ylab = "Latitude", axes = TRUE, las = 2, main = "SAMU Région Grand Est (Lambert93)", cex = 1.5, add = TRUE)

```

Population
==========
La colonne POPULATION est présetée sous forme de facteur. C'est vrai pour __ght__  et __a__.
Pour les transformer en nombre, il faut  d'abord les transforme en _character_ puis en _integer_, sion les résultats sont faux!

```{r}
str(ght@data)
```
On voit que POPULATION est un factor!

Transformation: Population par département
```{r}
ght$POPULATION <- as.integer(as.character(ght$POPULATION))
t <- tapply(as.numeric(ght$POPULATION), factor(ght$CODE_DEPT), sum)
t
sum(t)

```

et population par GHT
```{r}
t <- tapply(ght$POPULATION, factor(ght$GHT), sum)
t
sum(t)
barplot(sort(t), main = "Peuplement des GHT (2014)")
abline(h = mean(t), col = "red")

```
Le GHT le moins peuplé est le 4, le plus peuplé est le 10.

Pareil pour les surfaces et les densités
-----------------------------------------
```{r}
ght$SUPERFICIE <- as.numeric(as.character(ght$SUPERFICIE))
s <- tapply(ght$SUPERFICIE, factor(ght$GHT), sum)
s
round(t * 100 /s, 2)
sort(round(t * 100 /s, 2))
```
en nb d'habitants au km2

Par département
```{r}
t <- tapply(a$POPULATION, factor(a$DEP), sum)
s <- tapply(a$SUPERFICIE, factor(a$DEP), sum)
sort(round(t * 100 /s, 2))
```

